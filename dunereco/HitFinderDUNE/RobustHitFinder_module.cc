////////////////////////////////////////////////////////////////////////
// Class:       RobustHitFinder
// Module Type: producer
// File:        RobustHitFinder_module.cc
//
// Generated at Thu Aug 18 04:21:10 2016 by Matthew Thiesse using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

/*************************************************

Use this package with care, as it is unvalidated (as of 25 Aug 2016).
Also note that it can take quite a while to run because
of the HitLineFitAlg. Also, I don't yet trust the random seeding
of the algorithm. Need to work on that...

Let me know if there are any issues/requests/comments. 

m.thiesse@sheffield.ac.uk

**************************************************/


#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Optional/RandomNumberGenerator.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "larsim/RandomUtils/LArSeedService.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "lardataobj/AnalysisBase/T0.h"
#include "lardata/RecoBaseArt/HitCreator.h"
#include "larcore/Geometry/Geometry.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"

#include <math.h>
#include <memory>
#include <algorithm>
#include <fstream>
#include <iostream>
#include <vector>
#include <map>

#include "TMath.h"
#include "TVector3.h"
#include "TTree.h"
#include "TF1.h"

#include "CLHEP/Random/RandomEngine.h"

//for the counter position map
#include "dune/daqinput35t/PennToOffline.h"

#include "RobustHitFinderSupport.h"
#include "HitLineFitAlg.h"
#include "RMSHitFinderAlg.h"

namespace dune {
  class RobustHitFinder;
}

class dune::RobustHitFinder : public art::EDProducer {
public:
  explicit RobustHitFinder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  RobustHitFinder(RobustHitFinder const &) = delete;
  RobustHitFinder(RobustHitFinder &&) = delete;
  RobustHitFinder & operator = (RobustHitFinder const &) = delete;
  RobustHitFinder & operator = (RobustHitFinder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  bool ValidTrigger(std::vector<unsigned int> evtTriggers, unsigned int & c1arg, unsigned int & c2arg, unsigned int & trignumarg);
  float TimeToDriftDist(float thistime, unsigned int thistpc);
  float TimeToDisplacement(float thistime);
  float TimeToX(float thistime, unsigned int thistpc);
  float hitGeomDist(TVector3 hitloc, TVector3 trigloc1, TVector3 trigloc2);

  TTree * fTree;
  int run;
  int event;
  unsigned int c1;
  unsigned int c2;
  unsigned int trignum;
  float c1x;
  float c1y;
  float c1z;
  float c2x;
  float c2y;
  float c2z;
  int channel;
  int tpc;
  int signalsize;
  std::vector<float> signal;
  std::vector<float> signalFilter;
  float baseline;
  float rms;
  float baselineFilter;
  float rmsFilter;
  float integral;
  float integralFilter;
  float sigmaintegral;
  float sigmaintegralFilter;
  float amplitude;
  float amplitudeFilter;
  float peaktick;
  float peaktickFilter;
  float peaktime;
  float peaktimeFilter;
  int begintick;
  int endtick;
  int width;
  float hitx;
  float hity;
  float hitz;
  float hiterrxlo;
  float hiterrxhi;
  float hiterrylo;
  float hiterryhi;
  float hiterrzlo;
  float hiterrzhi;
  float perpdist;
  float hitt;
  float driftdist;
  bool countercut;
  float fitconstant;
  float fitconstanterr;
  float fitlinear;
  float fitlinearerr;
  float fitquadratic;
  float fitquadraticerr;
  float fitchi2;
  float fitsumsqrresidual;
  float fitndf;
  float fitmle;
  bool fitsuccess;
  bool fitrealhit;
  float segmentlength;

  bool fMakeTree;
  bool fDoWireAssns;
  bool fDoRawDigitAssns;
  float fHitGeomDistanceCut;
  std::string fWireModuleLabel;
  std::string fDigitModuleLabel;
  std::string fCounterT0ModuleLabel;
  std::vector<float> fEfield;
  int fSearchPreTicks;
  int fSearchPostTicks;

  float fHorizRangeMin;
  float fHorizRangeMax;
  float fVertRangeMin;
  float fVertRangeMax;
  float fC1Vert;
  float fC1Horiz;
  float fC2Vert;
  float fC2Horiz;
  UInt_t fSeedValue;
  std::map<unsigned int, std::pair<TVector3, std::vector<TVector3> > > fCounterPositionMap;

  dune::HitLineFitAlg fFitAlg;
  dune::RMSHitFinderAlg fHitFinderAlg;

  art::ServiceHandle<geo::Geometry> fGeom;
  art::ServiceHandle<art::RandomNumberGenerator> fRng;
  art::ServiceHandle<sim::LArSeedService> fSeed;
  art::ServiceHandle<art::TFileService> fTfs;
  detinfo::DetectorClocks const * fClks;
  detinfo::DetectorProperties const * fDetProp;
};


dune::RobustHitFinder::RobustHitFinder(fhicl::ParameterSet const & p)
  : fFitAlg(p.get<fhicl::ParameterSet>("HitLineFitAlg")),
    fHitFinderAlg(p.get<fhicl::ParameterSet>("RMSHitFinderAlg")),
    fClks(lar::providerFrom<detinfo::DetectorClocksService>()),
    fDetProp(lar::providerFrom<detinfo::DetectorPropertiesService>())

{
  this->reconfigure(p);

  fSeed->createEngine(*this,"HepJamesRandom","Seed");

  recob::HitCollectionCreator::declare_products(*this);
}

void dune::RobustHitFinder::produce(art::Event & e)
{
  recob::HitCollectionCreator hcol(*this, e);

  CLHEP::HepRandomEngine const & engine = fRng->getEngine("Seed");
  fFitAlg.SetSeed(engine.getSeed());

  // get recob::Wires
  art::Handle< std::vector< recob::Wire> > wireHandle;
  if (!e.getByLabel(fWireModuleLabel,wireHandle))
    {
      mf::LogError("RobustHitFinder") << "No recob::Wires found when expected";
      hcol.put_into(e);
      return;
    }

  // get associated raw digits
  art::FindOneP<raw::RawDigit> rawdigits(wireHandle,e,fWireModuleLabel);

  // Get all T0 products
  art::Handle< std::vector< anab::T0> > t0Handle;
  if (!e.getByLabel(fCounterT0ModuleLabel,t0Handle))
    {
      mf::LogError("RobustHitFinder") << "No T0s found in this event";
      hcol.put_into(e);
      return;
    }

  // get associated external triggers
  art::FindManyP<raw::ExternalTrigger> triggers(t0Handle,e,fCounterT0ModuleLabel);

  run = e.run();
  event = e.event();

  for (size_t i_t0 = 0; i_t0 < t0Handle->size(); i_t0++)
    {
      art::Ptr<anab::T0> pt0(t0Handle,i_t0);

      unsigned int tick0 = static_cast<unsigned int>(fClks->TPCG4Time2Tick(pt0->Time()));
      mf::LogInfo("RobustHitFinder") << "Found t0 at TPC tick = " << tick0;

      std::vector<art::Ptr<raw::ExternalTrigger> > trigvec = triggers.at(i_t0);

      std::vector<unsigned int> evtTriggers;
      for (auto const &trig : trigvec) evtTriggers.push_back(trig->GetTrigID());

      if (!ValidTrigger(evtTriggers,c1,c2,trignum)) continue;

      c1x = fCounterPositionMap[c1].first.X();
      c1y = fCounterPositionMap[c1].first.Y();
      c1z = fCounterPositionMap[c1].first.Z();
      c2x = fCounterPositionMap[c2].first.X();
      c2y = fCounterPositionMap[c2].first.Y();
      c2z = fCounterPositionMap[c2].first.Z();
    
      float distancecut = fHitGeomDistanceCut;
      if (trignum == 111)
        {
          fHorizRangeMin = -10;
          fHorizRangeMax = 170;
          fVertRangeMin = -50;
          fVertRangeMax = 250;
          fC1Vert = c1x;
          fC1Horiz = c1z;
          fC2Vert = c2x;
          fC2Horiz = c2z;
          distancecut *= fabs(TMath::Sin(TMath::ATan2(c1z-c2z,c1x-c2x)));
        }
      if (trignum == 112 || trignum == 113)
        {
          fHorizRangeMin = -50;
          fHorizRangeMax = 250;
          fVertRangeMin = -10;
          fVertRangeMax = 170;
          fC1Vert = c1z;
          fC1Horiz = c1x;
          fC2Vert = c2z;
          fC2Horiz = c2x;
          distancecut *= fabs(TMath::Cos(TMath::ATan2(c1z-c2z,c1x-c2x)));
        }
      fFitAlg.SetCounterPositions(fC1Vert,fC1Horiz,fC2Vert,fC2Horiz);
      fFitAlg.SetRanges(fHorizRangeMin,fHorizRangeMax,fVertRangeMin,fVertRangeMax);

      std::map<int,dune::ChannelInformation> chanMap;
      std::vector<dune::HitInformation> hitVec;

      for (size_t iwire = 0; iwire < wireHandle->size(); ++iwire)
	{
	  art::Ptr<recob::Wire> wire(wireHandle,iwire);
	  art::Ptr<raw::RawDigit> rawdigit = rawdigits.at(iwire);
	  
	  if (wire->View() != geo::kZ) continue;
	  
	  dune::ChannelInformation chan;
	  
	  chan.artWire = wire;
	  chan.artRawDigit = rawdigit;
	  
	  chan.signalVec.clear();
	  chan.signalFilterVec.clear();
	  
	  chan.channelID = wire->Channel();
	  chan.tpcNum = fGeom->ChannelToWire(chan.channelID)[0].TPC;
	  
	  chan.signalVec = wire->Signal();
	  chan.signalSize = chan.signalVec.size();
	  
	  if (fSearchPreTicks > 0 && fSearchPostTicks > 0)
	    { 
	      fHitFinderAlg.SetSearchTicks(tick0-fSearchPreTicks,tick0+fSearchPostTicks);
	    }	  
	  fHitFinderAlg.FindHits(chan);
	
	
	  if (chan.pulse_ends.size() < 1) continue;
	
	  double wirexyz[3];
	  fGeom->Wire(*(fGeom->ChannelToWire(chan.channelID).begin())).GetCenter(wirexyz);
	
	  for (size_t i_hit = 0; i_hit < chan.pulse_ends.size(); i_hit++)
	    {
	      dune::HitInformation hit;
	      hit.channelID = chan.channelID;
	      int begin_index = chan.pulse_ends[i_hit].first;
	      int end_index = chan.pulse_ends[i_hit].second;
	      hit.hitBeginTick = begin_index;
	      hit.hitEndTick = end_index;
	      std::vector<float>::iterator beginitr = chan.signalVec.begin()+begin_index;
	      std::vector<float>::iterator enditr = chan.signalVec.begin()+end_index;
	      std::vector<float> pulse(beginitr,enditr);
	      std::vector<float>::iterator fbeginitr = chan.signalFilterVec.begin()+begin_index;
	      std::vector<float>::iterator fenditr = chan.signalFilterVec.begin()+end_index;
	      std::vector<float> pulseFilter(fbeginitr,fenditr);
	      hit.hitAmplitude = *std::max_element(beginitr,enditr)-chan.baseline;
	      hit.hitAmplitudeFilter = *std::max_element(fbeginitr,fenditr)-chan.baselineFilter;
	      hit.hitWidth = end_index-begin_index;
	      hit.hitIntegral = std::accumulate(beginitr,enditr,0)-(hit.hitWidth*chan.baseline);
	      hit.hitIntegralFilter = std::accumulate(fbeginitr,fenditr,0)-(hit.hitWidth*chan.baselineFilter);
	      hit.hitSigmaIntegral = TMath::Sqrt(pulse.size())*TMath::RMS(pulse.size(),pulse.data());
	      hit.hitSigmaIntegralFilter = TMath::Sqrt(pulseFilter.size())*TMath::RMS(pulseFilter.size(),pulseFilter.data());
	      hit.hitPeakTick = std::distance(chan.signalVec.begin(),std::max_element(beginitr,enditr));
	      hit.hitPeakTickFilter = std::distance(chan.signalFilterVec.begin(),std::max_element(fbeginitr,fenditr));
	      hit.hitPeakTime = fClks->TPCTick2TrigTime(hit.hitPeakTick);
	      hit.hitPeakTimeFilter = fClks->TPCTick2TrigTime(hit.hitPeakTickFilter);

	      hit.hitt = hit.hitPeakTime - pt0->Time()/1000;
	   	      
	      hit.hitx = TimeToX(hit.hitt,chan.tpcNum);
	      hit.hity = 2.;
	      hit.hitz = static_cast<float>(wirexyz[2]);
	      hit.hiterrxlo = TMath::Sqrt(fabs(hit.hitx-TimeToDisplacement(fClks->TPCTick2TrigTime(hit.hitBeginTick)-pt0->Time()/1000)));
	      hit.hiterrxhi = TMath::Sqrt(fabs(hit.hitx-TimeToDisplacement(fClks->TPCTick2TrigTime(hit.hitEndTick)-pt0->Time()/1000)));
	      hit.hiterrylo = 0.;
	      hit.hiterryhi = 0.;
	      hit.hiterrzlo = sqrt(0.5);
	      hit.hiterrzhi = sqrt(0.5);
	      hit.driftdist = TimeToDriftDist(hit.hitt,chan.tpcNum);
	      hit.perpdist = hitGeomDist(TVector3(hit.hitx,2.,hit.hitz),TVector3(c1x,2.,c1z),TVector3(c2x,2.,c2z));
	      hit.countercut = false;
	      if (hit.perpdist < distancecut) hit.countercut = true;
	      hit.fitrealhit = false;

	      if (trignum == 111)
		{
		  hit.hithoriz = hit.hitz;
		  hit.hitvert = hit.hitx;
		  hit.hithorizerrlo = hit.hiterrzlo;
		  hit.hithorizerrhi = hit.hiterrzhi;
		  hit.hitverterrlo = hit.hiterrxlo;
		  hit.hitverterrhi = hit.hiterrxhi;
		}
	      else if (trignum == 112 || trignum == 113)
		{
		  hit.hithoriz = hit.hitx;
		  hit.hitvert = hit.hitz;
		  hit.hithorizerrlo = hit.hiterrxlo;
		  hit.hithorizerrhi = hit.hiterrxhi;
		  hit.hitverterrlo = hit.hiterrzlo;
		  hit.hitverterrhi = hit.hiterrzhi;
		}

	      recob::HitCreator temphit(*wire,
					fGeom->ChannelToWire(chan.channelID)[0],
					hit.hitBeginTick,
					hit.hitEndTick,
					hit.hitWidth,
					hit.hitPeakTick,
					sqrt(hit.hitWidth),
					hit.hitAmplitude,
					sqrt(hit.hitAmplitude),
					hit.hitIntegral,
					hit.hitSigmaIntegral,
					hit.hitIntegral,
					1,
					-1,
					1,
					int(hit.hitEndTick-hit.hitBeginTick+1));
	      hit.artHit = temphit.move();

	      if (hit.hitx > -400) hitVec.push_back(hit);
	    }
	  chanMap.emplace(std::make_pair(chan.channelID,chan));

	}

      dune::HitLineFitAlg::HitLineFitResults fitresult;
      int retval = fFitAlg.FindTrack(hitVec,fitresult);
      if (retval == 1 || retval == 0)
	{
	  fitconstant = fitresult.fitconstant;
	  fitconstanterr = fitresult.fitconstanterr;
	  fitlinear = fitresult.fitlinear;
	  fitlinearerr = fitresult.fitlinearerr;
	  fitquadratic = fitresult.fitquadratic;
	  fitquadraticerr = fitresult.fitquadraticerr;
	  fitchi2 = fitresult.fitchi2;
	  fitsumsqrresidual = fitresult.fitsumsqrresidual;
	  fitmle = fitresult.fitmle;
	  fitndf = fitresult.fitndf;
	  fitsuccess = fitresult.fitsuccess;
	  TF1 * model = new TF1("model","pol2",fHorizRangeMin,fHorizRangeMax);
	  model->SetParameters(fitconstant,fitlinear,fitquadratic);
	  for (size_t i_hit = 0; i_hit < hitVec.size(); ++i_hit)
	    {
	      dune::HitInformation & hit = hitVec.at(i_hit);
	      dune::ChannelInformation & chan = chanMap[hit.channelID];
	      channel = chan.channelID;
	      tpc = chan.tpcNum;
	      signalsize = chan.signalSize;
	      signal = chan.signalVec;
	      signalFilter = chan.signalFilterVec;
	      baseline = chan.baseline;
	      rms = chan.rms;
	      baselineFilter = chan.baselineFilter;
	      rmsFilter = chan.rmsFilter;
	      integral = hit.hitIntegral;
	      integralFilter = hit.hitIntegralFilter;
	      sigmaintegral = hit.hitSigmaIntegral;
	      sigmaintegralFilter = hit.hitSigmaIntegralFilter;
	      amplitude = hit.hitAmplitude;
	      amplitudeFilter = hit.hitAmplitudeFilter;
	      peaktick = hit.hitPeakTick;
	      peaktickFilter = hit.hitPeakTickFilter;
	      peaktime = hit.hitPeakTime;
	      peaktimeFilter = hit.hitPeakTimeFilter;
	      begintick = hit.hitBeginTick;
	      endtick = hit.hitEndTick;
	      width = hit.hitWidth;
	      hitx = hit.hitx;
	      hity = hit.hity;
	      hitz = hit.hitz;
	      hiterrxlo = hit.hiterrxlo;
	      hiterrxhi = hit.hiterrxhi;
	      hiterrylo = hit.hiterrylo;
	      hiterryhi = hit.hiterryhi;
	      hiterrzlo = hit.hiterrzlo;
	      hiterrzhi = hit.hiterrzhi;
	      perpdist = hit.perpdist;
	      hitt = hit.hitt;
	      driftdist = hit.driftdist;
	      countercut = hit.countercut;
	      fitrealhit = hit.fitrealhit;

	      segmentlength = 0.449;
	      if (fitsuccess && fitrealhit)
		{
		  if (trignum == 111)
		    {
		      double thetayz = TMath::ATan2(model->Eval(hitz+1)-model->Eval(hitz-1),2);
		      double tan2thetayz = TMath::Power(TMath::Tan(thetayz),2);
		      double y2z2 = ((c1y-c2y)*(c1y-c2y))/((c1z-c2z)*(c1z-c2z));
		      double projL = sqrt(1+tan2thetayz+y2z2);
		      segmentlength *= static_cast<float>(projL);//sqrt(1+TMath::Power(TMath::Tan(TMath::ATan2(model->Eval(hitz+1)-model->Eval(hitz-1),2)),2)+(((c1y-c2y)*(c1y-c2y))/((c1z-c2z)*(c1z-c2z))));
		    }
		  else if (trignum == 112 || trignum == 113)
		    {
		      double thetayx = TMath::ATan2(2,model->Eval(hitx+1)-model->Eval(hitx-1));
		      double tan2thetayx = TMath::Power(TMath::Tan(thetayx),2);
		      double y2x2 = ((c1y-c2y)*(c1y-c2y))/((c1x-c2x)*(c1x-c2x));
		      double projL = sqrt(1+tan2thetayx*(1+y2x2));
		      segmentlength *= static_cast<float>(projL);//sqrt(1+TMath::Power(TMath::Tan(TMath::ATan2(2,model->Eval(hitx+1)-model->Eval(hitx-1))),2)*(1+(((c1y-c2y)*(c1y-c2y))/((c1x-c2x)*(c1x-c2x)))));
		    }
		}

	      if (fMakeTree) fTree->Fill();
	      if (fitrealhit)
		{
		  hcol.emplace_back(hit.artHit,chan.artWire,chan.artRawDigit);
		}
	    }
	}
    }
  hcol.put_into(e);
}

void dune::RobustHitFinder::beginJob()
{
  DAQToOffline::MakeCounterPositionMap("","counterInformation.txt",fCounterPositionMap,0,0,0);

  if (fMakeTree)
    {
      fTree = fTfs->make<TTree>("RobustHitFinder","RobustHitFinder");
      fTree->Branch("run",&run,"run/I");
      fTree->Branch("event",&event,"event/I");
      fTree->Branch("c1",&c1,"c1/i");
      fTree->Branch("c2",&c2,"c2/i");
      fTree->Branch("trignum",&trignum,"trignum/i");
      fTree->Branch("c1x",&c1x,"c1x/F");
      fTree->Branch("c1y",&c1y,"c1y/F");
      fTree->Branch("c1z",&c1z,"c1z/F");
      fTree->Branch("c2x",&c2x,"c2x/F");
      fTree->Branch("c2y",&c2y,"c2y/F");
      fTree->Branch("c2z",&c2z,"c2z/F");
      fTree->Branch("channel",&channel,"channel/I");
      fTree->Branch("tpc",&tpc,"tpc/I");
      fTree->Branch("signalsize",&signalsize,"signalsize/I");
      //fTree->Branch("signal",&signal);
      //fTree->Branch("signalFilter",&signalFilter);
      fTree->Branch("baseline",&baseline,"baseline/F");
      fTree->Branch("rms",&rms,"rms/F");
      fTree->Branch("baselineFilter",&baselineFilter,"baselineFilter/F");
      fTree->Branch("rmsFilter",&rmsFilter,"rmsFilter/F");
      fTree->Branch("integral",&integral,"integral/F");
      fTree->Branch("integralFilter",&integralFilter,"integralFilter/F");
      fTree->Branch("sigmaintegral",&sigmaintegral,"sigmaintegral/F");
      fTree->Branch("sigmaintegralFilter",&sigmaintegralFilter,"sigmaintegralFilter/F");
      fTree->Branch("amplitude",&amplitude,"amplitude/F");
      fTree->Branch("amplitudeFilter",&amplitudeFilter,"amplitudeFilter/F");
      fTree->Branch("peaktick",&peaktick,"peaktick/F");
      fTree->Branch("peaktickFilter",&peaktickFilter,"peaktickFilter/F");
      fTree->Branch("peaktime",&peaktime,"peaktime/F");
      fTree->Branch("peaktimeFilter",&peaktimeFilter,"peaktimeFilter/F");
      fTree->Branch("begintick",&begintick,"begintick/I");
      fTree->Branch("endtick",&endtick,"endtick/I");
      fTree->Branch("width",&width,"width/I");
      fTree->Branch("hitx",&hitx,"hitx/F");
      fTree->Branch("hity",&hity,"hity/F");
      fTree->Branch("hitz",&hitz,"hitz/F");
      fTree->Branch("hiterrxlo",&hiterrxlo,"hiterrxlo/F");
      fTree->Branch("hiterrxhi",&hiterrxhi,"hiterrxhi/F");
      fTree->Branch("hiterrylo",&hiterrylo,"hiterrylo/F");
      fTree->Branch("hiterryhi",&hiterryhi,"hiterryhi/F");
      fTree->Branch("hiterrzlo",&hiterrzlo,"hiterrzlo/F");
      fTree->Branch("hiterrzhi",&hiterrzhi,"hiterrzhi/F");
      fTree->Branch("perpdist",&perpdist,"perpdist/F");
      fTree->Branch("hitt",&hitt,"hitt/F");
      fTree->Branch("driftdist",&driftdist,"driftdist/F");
      fTree->Branch("countercut",&countercut,"countercut/O");
      fTree->Branch("fitconstant",&fitconstant,"fitconstant/F");
      fTree->Branch("fitconstanterr",&fitconstanterr,"fitconstanterr/F");
      fTree->Branch("fitlinear",&fitlinear,"fitlinear/F");
      fTree->Branch("fitlinearerr",&fitlinearerr,"fitlinearerr/F");
      fTree->Branch("fitquadratic",&fitquadratic,"fitquadratic/F");
      fTree->Branch("fitquadraticerr",&fitquadraticerr,"fitquadraticerr/F");
      fTree->Branch("fitchi2",&fitchi2,"fitchi2/F");
      fTree->Branch("fitsumsqrresidual",&fitsumsqrresidual,"fitsumsqrresidual/F");
      fTree->Branch("fitndf",&fitndf,"fitndf/F");
      fTree->Branch("fitmle",&fitmle,"fitmle/F");
      fTree->Branch("fitsuccess",&fitsuccess,"fitsuccess/O");
      fTree->Branch("fitrealhit",&fitrealhit,"fitrealhit/O");
      fTree->Branch("segmentlength",&segmentlength,"segmentlength/F");
    }
}

void dune::RobustHitFinder::reconfigure(fhicl::ParameterSet const & p)
{
  fMakeTree = p.get<bool>("MakeTree");
  fDoWireAssns = p.get<bool>("DoWireAssns");
  fDoRawDigitAssns = p.get<bool>("DoRawDigitAssns");
  fHitGeomDistanceCut = p.get<float>("HitGeomDistanceCut");
  fCounterT0ModuleLabel = p.get<std::string>("CounterT0ModuleLabel");
  fWireModuleLabel = p.get<std::string>("WireModuleLabel");
  fEfield = p.get<std::vector<float> >("Efield");
  fSearchPreTicks = p.get<int>("SearchPreTicks",-1);
  fSearchPostTicks = p.get<int>("SearchPostTicks",-1);
}

bool dune::RobustHitFinder::ValidTrigger(std::vector<unsigned int> evtTriggers, unsigned int & c1arg, unsigned int & c2arg, unsigned int & trignumarg)
{
  int contains_111 = 0, contains_112 = 0, contains_113 = 0;
  int contains_Ntrigs = 0, contains_NU = 0, contains_NL = 0, contains_SU = 0, contains_SL = 0;
  int contains_EL = 0, contains_WU = 0, contains_TEL = 0;
  for (size_t i_c = 0; i_c < evtTriggers.size(); i_c++)
    {
      unsigned int trigID = evtTriggers[i_c];
      if (trigID >= 0 && trigID <= 5) contains_SL++;
      if (trigID >= 6 && trigID <= 15) contains_EL++;
      if (trigID >= 16 && trigID <= 21) contains_NL++;
      if (trigID >= 22 && trigID <= 27) contains_NU++;
      if (trigID >= 28 && trigID <= 37) contains_WU++;
      if (trigID >= 38 && trigID <= 43) contains_SU++;
      if (trigID >= 44 && trigID <= 92) contains_TEL++;
      if (trigID == 111) contains_111++;
      if (trigID == 112) contains_112++;
      if (trigID == 113) contains_113++;
      contains_Ntrigs++;
    }
  if (contains_111 + contains_112 + contains_113 != 1) return false;        // too many/few coincidences!
  if (contains_TEL &&
      (contains_NU || contains_NL || contains_SU || contains_SL || contains_EL || contains_WU)) return false;        // track probably doesn't go through detector
  if (contains_Ntrigs != 3) return false;        // too much/little going on!
  if (contains_111 && (contains_NU || contains_NL || contains_SU || contains_SL)) return false;        // 111 should not have NU/NL/SU/SL
  if (contains_112 && (contains_EL || contains_WU || contains_SU || contains_NL)) return false;        // 112 should not have EL/WU/SU/NL
  if (contains_113 && (contains_EL || contains_WU || contains_NU || contains_SL)) return false;        // 113 should not have EL/WU/NU/SL
  if (contains_111 && (!contains_EL || !contains_WU)) return false;        // incomplete trigger
  if (contains_112 && (!contains_NU || !contains_SL)) return false;        // incomplete trigger
  if (contains_113 && (!contains_SU || !contains_NL)) return false;        // incomplete trigger

  std::vector<unsigned int> counterIDs;
  trignumarg = 0;
  for (size_t i_c = 0; i_c < evtTriggers.size(); i_c++)
    {
      unsigned int trigID = evtTriggers[i_c];
      if (trigID >= 44 && trigID <= 100) continue;
      if (trigID >= 111 && trigID <= 113)
	{
	  trignumarg = trigID;
	  continue;
	}
      counterIDs.push_back(trigID);
    }
  if (counterIDs.size() != 2) return false;
  if (trignumarg == 0) return false;

  c1arg = 999; c2arg = 999;
  if (trignumarg == 112 || trignumarg == 113)
    {
      if (fCounterPositionMap[counterIDs[0]].first.X() > fCounterPositionMap[counterIDs[1]].first.X())
	{
	  c1arg = counterIDs[0];
	  c2arg = counterIDs[1];
	}
      else
	{
	  c1arg = counterIDs[1];
	  c2arg = counterIDs[0];
	}
    }
  else if (trignumarg == 111)
    {
      if (fCounterPositionMap[counterIDs[0]].first.Z() > fCounterPositionMap[counterIDs[1]].first.Z())
	{
	  c1arg = counterIDs[0];
	  c2arg = counterIDs[1];
	}
      else
	{
	  c1arg = counterIDs[1];
	  c2arg = counterIDs[0];
	}
    }
  if (c1arg == c2arg) return false;
  if (c1arg == 999 || c2arg == 999) return false;

  return true;
}

float dune::RobustHitFinder::TimeToDriftDist(float thistime, unsigned int thistpc)
{
  float vd = fDetProp->DriftVelocity(fEfield[0]);
  float v1 = fDetProp->DriftVelocity(fEfield[1]);
  float v2 = fDetProp->DriftVelocity(fEfield[2]);
  float v3 = fDetProp->DriftVelocity(fEfield[3]);

  float ld = -1, l1 = -1, l2 = -1, l3 = -1;

  try
    {
      if (thistpc == 1 || thistpc == 3 || thistpc == 5 || thistpc == 7)
	{
	  ld = fGeom->TPC(thistpc).MaxX()-0.511;
	  l1 = 0.511-fGeom->TPC(thistpc).PlaneLocation(0)[0];
	  l2 = fGeom->TPC(thistpc).PlaneLocation(0)[0]-fGeom->TPC(thistpc).PlaneLocation(1)[0];
	  l3 = fGeom->TPC(thistpc).PlaneLocation(1)[0]-fGeom->TPC(thistpc).PlaneLocation(2)[0];
	}
      else if (thistpc == 0 || thistpc == 2 || thistpc == 4 || thistpc == 6)
	{
	  ld = -8.490-fGeom->TPC(thistpc).MinX();
	  l1 = fGeom->TPC(thistpc).PlaneLocation(0)[0]+8.490;
	  l2 = fGeom->TPC(thistpc).PlaneLocation(1)[0]-fGeom->TPC(thistpc).PlaneLocation(0)[0];
	  l3 = fGeom->TPC(thistpc).PlaneLocation(2)[0]-fGeom->TPC(thistpc).PlaneLocation(1)[0];
	}
    }
  catch (cet::exception &e)
    {
      mf::LogError("RobustHitFinder") << e;
      return -99999;
    }

  if (ld < 0 || l1 < 0 || l2 < 0 || l3 < 0) return -99998;

  float t3max = l3/v3;
  float t2max = t3max+(l2/v2);
  float t1max = t2max+(l1/v1);
  float tdmax = t1max+(ld/vd);

  if      (0     <= thistime && thistime < t3max) return v3*thistime;
  else if (t3max <= thistime && thistime < t2max) return l3+v2*(thistime-t3max);
  else if (t2max <= thistime && thistime < t1max) return l3+l2+v1*(thistime-t2max);
  else if (t1max <= thistime && thistime < tdmax) return l3+l2+l1+vd*(thistime-t1max);

  return -99997;
}

float dune::RobustHitFinder::TimeToDisplacement(float thistime)
{
  return thistime*fDetProp->DriftVelocity(fEfield[0]);
}

float dune::RobustHitFinder::TimeToX(float thistime, unsigned int thistpc)
{
  float driftdistance = TimeToDriftDist(thistime,thistpc);
  if (driftdistance < -89999) return driftdistance;
  try
    {
      if (thistpc == 1 || thistpc == 3 || thistpc == 5 || thistpc == 7)
	{
	  return (fGeom->TPC(thistpc).PlaneLocation(2)[0]+driftdistance);
	}
      else if (thistpc == 0 || thistpc == 2 || thistpc == 4 || thistpc == 6)
	{
	  return (fGeom->TPC(thistpc).PlaneLocation(2)[0]-driftdistance);
	}
    }
  catch (cet::exception &e)
    {
      mf::LogError("RobustHitFinder") << e;
    }
  return -99995;
}

float dune::RobustHitFinder::hitGeomDist(TVector3 hitloc, TVector3 trigloc1, TVector3 trigloc2)
{
  return (((hitloc-trigloc1).Cross(hitloc-trigloc2)).Mag()/(trigloc2-trigloc1).Mag());
}

DEFINE_ART_MODULE(dune::RobustHitFinder)
